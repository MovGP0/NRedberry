using System.Collections;

namespace NRedberry.Core.Combinatorics;

/// <summary>
/// Enumerates the subgroup generated by a set of permutations by iterative compositions.
/// </summary>
/// <typeparam name="T">Permutation implementation.</typeparam>
public sealed class PermutationsSpanIterator<T> : IEnumerator<T>
    where T : Permutation
{
    private readonly SortedSet<T> _set;
    private List<T> _upperLayer;
    private List<T> _lowerLayer;
    private List<T> _nextLayer;
    private bool _forward;
    private int _upperIndex;
    private int _lowerIndex;

    private T? _current;

    public PermutationsSpanIterator(List<T> permutations)
    {
        if (permutations == null || permutations.Count == 0)
        {
            throw new ArgumentException("Permutations list must contain at least one element.", nameof(permutations));
        }

        _set = new SortedSet<T>();
        _upperLayer = [permutations[0]];
        _lowerLayer = permutations;
        _nextLayer = [];
        _forward = false;
        _upperIndex = 0;
        _lowerIndex = 0;
    }

    public T Current => _current!;

    object IEnumerator.Current => _current!;

    public bool MoveNext()
    {
        _current = NextInternal();
        return _current != null;
    }

    public void Reset()
    {
        throw new NotSupportedException();
    }

    public void Dispose()
    {
        // nothing to dispose
    }

    private T? NextInternal()
    {
        T? composition = default;
        while (composition == null)
        {
            if (_forward)
            {
                composition = TryPair(_upperLayer[_upperIndex], _lowerLayer[_lowerIndex]);
                AdvanceIndices();
                if (_lowerLayer.Count == 0)
                {
                    break;
                }

                _forward = !_forward;
            }
            else
            {
                composition = TryPair(_lowerLayer[_lowerIndex], _upperLayer[_upperIndex]);
                _forward = !_forward;
            }
        }

        return composition;
    }

    private void AdvanceIndices()
    {
        if (++_upperIndex < _upperLayer.Count)
        {
            return;
        }

        _upperIndex = 0;
        if (++_lowerIndex < _lowerLayer.Count)
        {
            return;
        }

        _lowerIndex = 0;
        _upperLayer = new List<T>(_set);
        _lowerLayer = _nextLayer;
        _nextLayer = [];
    }

    private T? TryPair(T p0, T p1)
    {
        var composition = (T)p0.Composition(p1);

        if (_set.TryGetValue(composition, out var existing))
        {
            if (existing.Equals(composition))
            {
                return default;
            }

            throw new InconsistentGeneratorsException(composition + " and " + existing);
        }

        _set.Add(composition);
        _nextLayer.Add(composition);
        return composition;
    }
}
